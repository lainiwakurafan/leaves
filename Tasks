3.04:
Done
    – Finished backchannel dependency injection
    – Finished HttpApiClient dependency injection
    – Found the problem with IBearerTokenProvider and http request identification

4.04:
Todo
    main tasks:
        * Fix request identification mechanism
        * Complete GoogleCalendarClient
        – Deprecate GoogleCalendarManager whos only goal is to provide access_token
        – Reimplement GoogleOAuthService -> GoogleOAuthClient
        – Make Core.Web assembly
    small refactors:
        – Remove IBackChannelHttpHandler
        – Move out IMvcHelper to Core.Web
        – Rename Dtos with Contracts
Done


TASKS:
    1) Implement monad
    2) Make CallHttpApiResult internal and replace with public ICallHttpApiResult


- OperationFlow
    - Need to pass TResult instance in there => IOperationFlow + IOperationResultFactory<TResult> + open generic DI register
    – OperationFlowState needs to receive TResult instance and we can not create it with new(), not good
    - Need good non-static design with OperationFlow + OperationFlowState + DI, extensions only for Task<OpFlowState>



– for scoped services https://wildermuth.com/2016/08/07/ASP-NET-Core-Dependency-Injection
- circular composite operation

– What is Composition Root?
- ConcurrentDictionary for composite operation
– https://blog.oneunicorn.com/2016/11/01/ef-core-dependency-injection-internals/
– https://github.com/aspnet/DependencyInjection/issues/433
– Composite operation circular execution
– Get rid of OperationResult – too generic

– Core.Abstractions, Core.Web, Core.Data, Core.Data.SqLite
– Implement refresh token validation
– Logging
– Activate HTTPS
– API versioning
+ Refactor Client: make services and managers (helpers)
+ Move Operations to separate assembly to use in Client